org.opalj {

  # Configuration for the Bytecode Representation subproject which provides handling for Java Bytecode
  br {
    # The CFG's structure is validated; primarily of interest when the algorithms related to
    # computing the CFG are maintained, extended, or changed.
    cfg.CFG.Validate = false,
    cfg.CFG.DF.Solver.Trace = false,

    # Allows to enforce Java 11+ call semantics (i.e., invokeinterface may invoke private methods)
    Project.enforceJava11CallSemantics = false,

    reader {
      ClassFileReader {
        BytecodeOptimizer {
          simplifyControlFlow = true, // default is "true"
          logControlFlowSimplification = false // default is "false"
        },
        Invokedynamic {
          rewrite = true, // default is "true"
          logLambdaRewrites = false, // default is "false"
          logStringConcatRewrites = false, // default is "false"
          logObjectMethodsRewrites = false, // default is "false"
          logUnknownInvokeDynamics = true // default is "true"
        },
        DynamicConstants {
          rewrite = true, // default is "true"
          logRewrites = false, // default is "false"
          logUnknownDynamicConstants = true, // default is "true"
          logUnresolvedDynamicConstants = true // default is "true"
        },
        deleteSynthesizedClassFilesAttributes = true // default is "true"
      }
    }

    // Configuration for Java analyses
    analyses {
      cg {

        callBySignatureResolution = false

        ClosedPackagesKey {
          analysis = "org.opalj.br.analyses.cg.AllPackagesClosed" # considers all packages closed (e.g. suitable when analyzing an application)

          #analysis = "org.opalj.br.analyses.cg.OpenCodeBase" # considers all packages open (e.g. suitable for security analyses)

          #analysis = "org.opalj.br.analyses.cg.ClosedPackagesConfiguration"
          #closedPackages = "java(/.*)*"
          # Use a regular expresion (e.g. "java(/.*)*") to specify all packages
          # that shall be considered closed. In some cases, it might be easier to 
          # specify all open packages. In this case it's possible to invert the
          # specified regular expression (e.g. "^(java(/.*)*)"). The latter example
          # would consider all packages except the java packages as closed.

        }

        ClassExtensibilityKey {
          analysis = "org.opalj.br.analyses.cg.ConfiguredFinalClasses"
          finalClasses = [] # used by org.opalj.br.analyses.cg.ConfiguredFinalClasses
        }

        # Configuration for which methods should be considered entrypoints for the program under analysis
        InitialEntryPointsKey {
          # @brief Specifies the implementation that computes the entry points
          # @type subclass
          # @constraint org.opalj.br.analyses.cg.EntryPointFinder
          analysis = "org.opalj.br.analyses.cg.ApplicationWithoutJREEntryPointsFinder"

          # Additional preconfigured entry points
          # Default values are entry points of the JDK
          # additional entry points can be specified by adding a respective tuple that must consist of
          # a class name and a method name and can be refined by also defining a method descriptor.
          # In addition, the specified class name can be suffixed with a "+" which implies that all methods that match
          # the specified name -- and if definied descriptor -- from subtypes are considered too.
          # eg.:
          # entryPoints = [
          #   {declaringClass = "java/util/List+", name = "add"},
          #   {declaringClass = "java/util/List", name = "remove", descriptor = "(I)Z"}
          # ]
          # Please note that the first entry point, by adding the "+" to the declaring class' name, considers all
          # "add" methods from all subtypes. In constrast, the second entry does specify a descriptor and does not
          # consider list subtypes (by not suffixing a plus to the declaringClass) which implies that only the remove
          # method with this descriptor is considered as entry point
          entryPoints = [
            {declaringClass = "java/lang/System", name = "initializeSystemClass", descriptor = "()V"},
            {declaringClass = "java/lang/Thread", name = "<init>", descriptor = "(Ljava/lang/ThreadGroup;Ljava/lang/Runnable;)V"},
            {declaringClass = "java/lang/Thread", name = "<init>", descriptor = "(Ljava/lang/ThreadGroup;Ljava/lang/String;)V"},
            {declaringClass = "java/lang/ThreadGroup", name = "<init>", descriptor = "()V"},
            {declaringClass = "java/lang/Thread", name = "exit", descriptor = "()V"},
            {declaringClass = "java/lang/ThreadGroup", name = "uncaughtException", descriptor = "(Ljava/lang/Thread;Ljava/lang/Throwable;)V"},
            {declaringClass = "java/lang/ref/Reference$ReferenceHandler", name = "run", descriptor = "()V"},
            {declaringClass = "java/lang/ClassLoader", name = " <init>", descriptor = "()V"},
            {declaringClass = "java/lang/ClassLoader", name = "loadClassInternal", descriptor = "(Ljava/lang/String;)Ljava/lang/Class;"},
            {declaringClass = "java/lang/ClassLoader", name = "checkPackageAccess", descriptor = "(Ljava/lang/Class;Ljava/security/ProtectionDomain;)V"},
            {declaringClass = "java/lang/ClassLoader", name = "addClass", descriptor = "(Ljava/lang/Class;)V"},
            {declaringClass = "java/lang/ClassLoader", name = "findNative", descriptor = "(Ljava/lang/ClassLoader;Ljava/lang/String;)J"},
            {declaringClass = "java/security/PrivilegedActionException", name = "<init>", descriptor = "(Ljava/lang/Exception;)V"}
          ]
        }

        # Configuration for which types should be considered existing at the start of the program under analysis
        InitialInstantiatedTypesKey {
          # @brief Specifies the implementation that computes the initially instantiated types
          # @type subclass
          # @constraint org.opalj.br.analyses.cg.InstantiatedTypesFinder
          analysis = "org.opalj.br.analyses.cg.ApplicationInstantiatedTypesFinder"

          # Additional preconfigured initially instantiated types
          instantiatedTypes = [

          ]
        }
      }
    }
  }

  fpcf {

    # Prints out information about the executed analyses.
    analyses.FPCFAnalysesManager {
      Trace = true
    }

    registry {
      analyses {
        "L0CompileTimeConstancyAnalysis" {
          description = "Determines if static fields are compile time constants.",
          eagerFactory = "org.opalj.br.fpcf.analyses.EagerL0CompileTimeConstancyAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.LazyL0CompileTimeConstancyAnalysis",
          default = true
        },
        "L0SelfReferenceLeakageAnalysis" {
          description = "Determines if an object may leak its self reference (`this`).",
          eagerFactory = "org.opalj.br.fpcf.analyses.L0SelfReferenceLeakageAnalysis",
          default = true
          #TODO This one does not yet have a lazy factory
        },
        "L1ThrownExceptionsAnalysis" {
          description = "Determines the exceptions that are thrown by a method.",
          eagerFactory = "org.opalj.tac.fpcf.analyses.EagerL1ThrownExceptionsAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.LazyL1ThrownExceptionsAnalysis",
          default = true
        },
        "L0AllocationFreenessAanalysis" {
          description = "Determines if a method may (transitively) cause allocations.",
          eagerFactory = "org.opalj.br.fpcf.analyses.EagerL0AllocationFreenessAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.LazyL0AllocationFreenessAnalysis",
          default = true
        },
        "StaticDataUsageAnalysis" {
          description = "Determines if a method uses only compile time constant static state.",
          eagerFactory = "org.opalj.br.fpcf.analyses.EagerStaticDataUsageAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.LazyStaticDataUsageAnalysis",
          default = true
        },
        "L0PurityAnalysis" {
          description = "Determines a method's purity.",
          eagerFactory = "org.opalj.br.fpcf.analyses.EagerL0PurityAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.LazyL0PurityAnalysis"
        },
        "ClassImmutabilityAnalysis" {
          description = "Determines the immutability of individual classes.",
          eagerFactory = "org.opalj.br.fpcf.analyses.immutability.EagerClassImmutabilityAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.immutability.LazyClassImmutabilityAnalysis",
          default = true
        },
        "TypeImmutabilityAnalysis" {
          description = "Determines the immutability of types (i.e., sets of classes).",
          eagerFactory = "org.opalj.br.fpcf.analyses.immutability.EagerTypeImmutabilityAnalysis",
          lazyFactory = "org.opalj.br.fpcf.analyses.immutability.LazyTypeImmutabilityAnalysis",
          default = true
        },
        "SimpleFieldAccessInformationAnalysis" {
          description = "Determines the direct read and write accesses to fields without receiver or param information.",
          eagerFactory = "org.opalj.br.fpcf.analyses.EagerSimpleFieldAccessInformationAnalysis",
        }
      }
    }

    analysis {
      L0SelfReferenceLeakage {
        debug = true // default is "false"
      }
    },

    android {
      AndroidEntryPointFinder {
        # These methods are considered entry points for an Android app.
        entryPoints = [
          {cf = "android/app/Activity", name = "onCreate", desc = "(Landroid/os/Bundle;)V"}
          {cf = "android/app/Activity", name = "onRestart", desc = "()V"},
          {cf = "android/app/Activity", name = "onStart", desc = "()V"},
          {cf = "android/app/Activity", name = "onResume", desc = "()V"},
          {cf = "android/app/Activity", name = "onStop", desc = "()V"},
          {cf = "android/app/Activity", name = "onDestroy", desc = "()V"},
          {cf = "android/app/Activity", name = "onActivityResult", desc = "()V"},
          {cf = "android/app/Service", name = "onCreate", desc = "()V"},
          {cf = "android/app/Service", name = "onStartCommand", desc = "(Landroid/content/Intent;II)V"},
          {cf = "android/app/Service", name = "onBind", desc = "(Landroid/content/Intent;)Landroid/os/IBinder;"},
          {cf = "android/app/Service", name = "onRebind", desc = "(Landroid/content/Intent;)V"},
          {cf = "android/app/Service", name = "onStart", desc = "(Landroid/content/Intent;I)V"},
          {cf = "android/app/Service", name = "onDestroy", desc = "()V"},
          {cf = "android/content/ContentProvider",name = "onCreate", desc = "()V"},
          {cf = "android/location/LocationListener",name = "onProviderDisabled", desc = "(Ljava/lang/String;)V"},
          {cf = "android/location/LocationListener",name = "onProviderEnabled", desc = "(Ljava/lang/String;)V"},
          {cf = "android/location/LocationListener",name = "onStatusChanged", desc = "(Ljava/lang/String;ILandroid/os/Bundle;)V"},
          {cf = "android/content/BroadcastReceiver",name = "onReceive",desc = "(Landroid/content/Context;Landroid/content/Intent;)V"}
        ]
      }
    }
  }

}
