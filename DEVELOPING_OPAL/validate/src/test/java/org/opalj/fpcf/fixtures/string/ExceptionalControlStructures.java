/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.fpcf.fixtures.string;

import org.opalj.fpcf.properties.string.*;

import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Various tests that test general compatibility with the control flow generated by try-catch(-finally) statements.
 * <p>
 * Since this type of statement can compile to multiple instances of calls that were initially defined in "finally"
 * blocks, more sink calls may be generated than visible in the source code.
 *
 * @see SimpleStringOps
 */
public class ExceptionalControlStructures {

    /**
     * Serves as the sink for string variables to be analyzed.
     */
    public void analyzeString(String s) {}

    @Invalid(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.LOW)
    @PartiallyConstant(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "File Content:.*")
    @Failure(sinkIndex = 0, levels = Level.L0)
    @Constant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "File Content:")
    @PartiallyConstant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(File Content:|File Content:.*)")
    @Failure(sinkIndex = 1, levels = Level.L0)
    @Constant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "File Content:")
    @PartiallyConstant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(File Content:|File Content:.*)")
    @Failure(sinkIndex = 2, levels = Level.L0)
    public void tryFinally(String filename) {
        StringBuilder sb = new StringBuilder("File Content:");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Exception ignore) {
        } finally {
            analyzeString(sb.toString());
        }
    }

    @Invalid(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.LOW)
    @PartiallyConstant(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "=====.*")
    @Failure(sinkIndex = 0, levels = Level.L0)
    // Exception case without own thrown exception
    @Constant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "==========")
    @PartiallyConstant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(=====.*=====|==========)")
    @Failure(sinkIndex = 1, levels = Level.L0)
    // The following cases are detected:
    // 1. Code around Files.readAllBytes failing, throwing a non-exception Throwable -> no append (Pos 1)
    // 2. Code around Files.readAllBytes failing, throwing an exception Throwable -> exception case append (Pos 4)
    // 3. First append succeeds, throws no exception -> only first append (Pos 2)
    // 4. First append is executed but throws an exception Throwable -> both appends (Pos 3)
    @Constant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "(=====|==========)")
    @PartiallyConstant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(=====|=====.*|=====.*=====|==========)")
    @Failure(sinkIndex = 2, levels = Level.L0)
    public void tryCatchFinally(String filename) {
        StringBuilder sb = new StringBuilder("=====");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Exception ignore) {
            sb.append("=====");
        } finally {
            analyzeString(sb.toString());
        }
    }

    @Invalid(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.LOW)
    @PartiallyConstant(sinkIndex = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "BOS:.*")
    @Failure(sinkIndex = 0, levels = Level.L0)
    @Constant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "BOS::EOS")
    @PartiallyConstant(sinkIndex = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(BOS:.*:EOS|BOS::EOS)")
    @Failure(sinkIndex = 1, levels = Level.L0)
    @Constant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.LOW, value = "BOS::EOS")
    @PartiallyConstant(sinkIndex = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(BOS:.*:EOS|BOS::EOS)")
    @Failure(sinkIndex = 2, levels = Level.L0)
    public void tryCatchFinallyWithThrowable(String filename) {
        StringBuilder sb = new StringBuilder("BOS:");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Throwable t) {
            sb.append(":EOS");
        } finally {
            analyzeString(sb.toString());
        }
    }
}
