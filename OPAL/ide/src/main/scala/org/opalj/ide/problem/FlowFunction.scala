/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj
package ide
package problem

import scala.language.implicitConversions

import scala.collection
import scala.collection.immutable

import org.opalj.fpcf.SomeEOptionP

/**
 * Interface representing IDE flow functions.
 *
 * @author Robin Körkemeier
 */
trait FlowFunction[Fact <: IDEFact] {
    type FactsAndDependees = FlowFunction.FactsAndDependees[Fact]

    implicit def setOfFactsToFactsAndDependees(facts: collection.Set[? <: Fact]): FactsAndDependees = {
        (facts.toSet, immutable.Set.empty)
    }

    /**
     * Compute the facts that are generated by this flow function and the dependees that can cause new facts to be
     * generated
     *
     * @return a set of facts and a set of dependees (a fact that is returned once must also be returned with every
     *         subsequent call)
     */
    def compute(): FactsAndDependees
}

object FlowFunction {
    type FactsAndDependees[Fact] = (collection.Set[Fact], collection.Set[SomeEOptionP])
}

/**
 * Special flow function that always returns the input fact.
 *
 * @author Robin Körkemeier
 */
case class IdentityFlowFunction[Fact <: IDEFact](sourceFact: Fact) extends FlowFunction[Fact] {
    override def compute(): FactsAndDependees =
        immutable.Set(sourceFact)
}

/**
 * Special flow function that always returns an empty set.
 *
 * @author Robin Körkemeier
 */
case class EmptyFlowFunction[Fact <: IDEFact]() extends FlowFunction[Fact] {
    override def compute(): FactsAndDependees =
        immutable.Set.empty[Fact]
}
